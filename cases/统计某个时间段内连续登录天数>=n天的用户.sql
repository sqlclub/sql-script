/*
需求:
要求统计某个时间段内连续登录天数>=5天的用户
数据如下:
uid,login_time
1,'2016-11-25 13:30:45'
1,'2016-11-24 13:30:45'
1,'2016-11-24 10:30:45'
1,'2016-11-24 09:30:45'
1,'2016-11-23 09:30:45'
1,'2016-11-10 09:30:45'
1,'2016-11-09 09:30:45'
1,'2016-11-01 09:30:45'
1,'2016-10-31 09:30:45'
2,'2016-11-25 13:30:45'
2,'2016-11-24 13:30:45'
2,'2016-11-23 10:30:45'
2,'2016-11-22 09:30:45'
2,'2016-11-21 09:30:45'
2,'2016-11-20 09:30:45'
2,'2016-11-19 09:30:45'
2,'2016-11-02 09:30:45'
2,'2016-11-01 09:30:45'
2,'2016-10-31 09:30:45'
2,'2016-10-30 09:30:45'
2,'2016-10-29 09:30:45'
*/

-- 1. 建表
set hive.exec.mode.local.auto=true;   --开启Hive的本地模式

drop table if exists user_login;
create table user_login(
    uid int,
    login_time string);

insert into user_login values
(1,'2016-11-25 13:30:45'),
(1,'2016-11-24 13:30:45'),
(1,'2016-11-24 10:30:45'),
(1,'2016-11-24 09:30:45'),
(1,'2016-11-23 09:30:45'),
(1,'2016-11-10 09:30:45'),
(1,'2016-11-09 09:30:45'),
(1,'2016-11-01 09:30:45'),
(1,'2016-10-31 09:30:45'),
(2,'2016-11-25 13:30:45'),
(2,'2016-11-24 13:30:45'),
(2,'2016-11-23 10:30:45'),
(2,'2016-11-22 09:30:45'),
(2,'2016-11-21 09:30:45'),
(2,'2016-11-20 09:30:45'),
(2,'2016-11-19 09:30:45'),
(2,'2016-11-02 09:30:45'),
(2,'2016-11-01 09:30:45'),
(2,'2016-10-31 09:30:45'),
(2,'2016-10-30 09:30:45'),
(2,'2016-10-29 09:30:45');


-- 2. 处理
-- lead函数:
-- 第一个参数: 是指定的列（这里用登陆日期）
-- 第二个参数: 是当前行向后几行的值，这里用的是4，也就是第五次登录的日期
-- 第三个参数: 是如果返回的空值可以用指定值替代，这里没有使用第三个参数，返回空值

select distinct uid from (
    select uid,datediff(login_5_day, login_time) + 1 diff_day from (
      -- 用户按login_time排序，加入第五天的登录时间
      select *,
      lead(login_time, 4) over(partition by uid order by login_time asc) login_5_day
      from user_login
    ) a
)b where diff_day=5;

/*
结果:
2
*/
-- 只有uid=2连续登录了5天以上


